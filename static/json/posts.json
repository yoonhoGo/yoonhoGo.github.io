[{"fields":{"path":"/blog/2018-08-15/블로그-시작/"},"timeToRead":1,"internal":{"content":"\n블로그를 운영하는데 있어서 가장 기본이 되는 것이 무엇인가 많이 생각해봤습니다. 제 생각에는 아무래도 구독자가 가장 읽기 편한 환경을 만드는 것이라고 생각했습니다. 좋은 글도 읽히지 않으면 기억에 남기 힘들고 읽기도 힘들기 때문이죠. 저는 그런 블로그들에서 벗어나야한다고 생각했습니다.\n\n앞으로 꾸준히 포스트를 올리기 위해서 노력하겠지만 글을 쓴다는게 매번 쉬운 일은 아니더군요. 그래서 짧은 글들도 자주 올라올거라고 생각합니다.\n제 글이 여러분에게 도움이 될 수 있기를 바랍니다. 오늘은 여기까지.\n"},"frontmatter":{"date":"August 15, 2018","title":"블로그를 시작해도 될까요?","slug":"/2018-08-15/블로그-시작","tags":[]}},{"fields":{"path":"/blog/2018-08-17/Ghost/"},"timeToRead":1,"internal":{"content":"\n개발 블로그를 시작해야지생각하면서 고려했던 블로그 플랫폼이 많이 있었습니다.\n\n1. Medium\n2. tumblr\n3. Ghost\n4. GitHub pages + Jekyll(or Hexo or Hugo or Ghost)\n5. 등등등…\n\n아무래도 개발자다보니 GitHub + Jekyll로 가려고 계속 시도를 했습니다. 그치만 어느 순간 글을 쓰는 것보다도 디자인에 계속 더 신경을 쓰고 있더군요. 아무래도 주객이 전도 바뀌었다 싶어서 여러 글을 찾아보다가\n[PIGNOSE](https://blog.pigno.se/post/156817828203/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%99%9C-%ED%85%80%EB%B8%94%EB%9F%AC%EB%A5%BC-%ED%83%9D%ED%95%A0-%EC%88%98-%EB%B0%96%EC%97%90-%EC%97%86%EC%97%88%EB%82%98)님의 글을 참고해서 텀블러도 사용해봤습니다. 텀블러 무료 테마가 제가 바라던게 무료로 없었고, 만들자니 학습곡선이 가파르고(하하;;) 그래서 이리돌고 저리돌다가 결국 미디엄에 비상 착륙했습니다.\n\n미디엄이 제가 원하는 테마를 갖췄는지는 아직 모르겠습니다. 그렇지만 결국 제가 테마를 원했던 이유는 가독성과 깔끔한 디자인, 쓰기 편한 부분, 이후 이사 가기가 편해야 하는점 등을 고려했을 때 합격점에 들어서있는 플랫폼이라고 생각했습니다.\n\n결국 만족스러운 답을 아직 만나지는 못했습니다. 그치만 일단 블로그를 시작할 수 있게 되었다는 점에서 나중에 옮기더라도 아무것도 안적는 것보다 나은 것 같네요! 여러분도 블로그를 고민하신다면 무엇을 고민하시더라도 목적이 있으실텐데 그건 80% 이상 글을 ‘쓰기’ 위함이실텐데 저처럼 여기저기 방황하다가 목적을 잃지 마시고 저랑 같이 시작부터 하시죠! 😄\n\n그럼 오늘은 이만 총총…3\n\n---\n\n고민했던 흔적들의 수많은 링크들 중\n\n1.  [https://themeisle.com/blog/wordpress-vs-ghost-vs-medium/](https://themeisle.com/blog/wordpress-vs-ghost-vs-medium/)\n"},"frontmatter":{"date":"August 17, 2018","title":"언젠가 Ghost로 옮기길 바라며…","slug":"/2018-08-17/Ghost","tags":["Ghost","Tumblr","Github Pages"]}},{"fields":{"path":"/blog/2018-08-19/Anaconda-Uninstall-macOS/"},"timeToRead":1,"internal":{"content":"\n제가 학교에 재학 중일 때는 개인적으로 파이썬을 자주 쓰기도 하고 프로젝트에서도 머신러닝이나 데이터 분석때 파이썬을 자주 쓰다보니 패키지 관리를 위해서나 호환성을 위해서나 아나콘다를 설치해서 쓰는 일이 잦았습니다.\n\n그런데 회사에서 일을 할때는 주로 Node.js를 쓰고 있어서 최근 파이썬을 사용하는 일이 전무했습니다. 언젠간 쓰겠거니 싶어서 여태 신경 안쓰고 놔두고 있었는데 요즘 용량에 허덕이면서(128GB… 하핫) 과감히 삭제를 결심했습니다.\n\n몇가지 글을 찾아보면서 삭제 방법을 찾아봤는데요. 앱을 이용하여 삭제하는 것과 수동으로 삭제 하는 방법 두가지를 소개합니다. 제일 정확한 방법은 아닐지 모르겠습니다만 찾아본 방법 중에 제일 단순하더군요.(사실 맥 사용 기간이 얼마 안된 것도 있습니다…)\n\n#### App Cleaner\n\n앱스토어에서 “[App Cleaner](https://itunes.apple.com/kr/app/app-cleaner-uninstaller/id1013897218?mt=12)”라는 앱을 받으면 Anaconda Navigator.app을 삭제할 수 있습니다. 이때 관련된 아나콘다 패키지들도 다 찾아주더라구요. 총 4.5GB의 결과물을 찾을 수 있었습니다. 개인적으로는 AppDelete보다 좋았습니다.(무료기도 하구요 ㅎ)\n\n![App Cleaner 실행 화면](https://cdn-images-1.medium.com/max/1600/1*vTb29refTamA8FHbBc-Teg.png)\n\n#### 직접 삭제\n\n두번째 방법은 일일이 해당 경로를 삭제하는 것입니다. 위에 나타난 경로 그대로 삭제하면 될 것 같네요. 불안하시면 앱을 이용해주세요 ㅎㅎㅎ\n\n```bash\n$ rm -rf ~/anaconda3 ~/.conda ~/.anaconda ~/.condarc\n$ rm ~/Library/Application Support/binstar/*anaconda*\n$ rm ~/Library/Receipts/io.continuum.pkg.anaconda*\n```\n\n잘못된 내용이 있으면 댓글↓↓↓ 달아주세요😃\n\n---\n\n참고 링크입니다.\n\n1. [Uninstall Anaconda on a Mac - Full Removal Guide](https://nektony.com/how-to/uninstall-anaconda-on-a-mac)\n2. [‎Mac App Store에서 제공하는 Cleaner-App](https://itunes.apple.com/kr/app/app-cleaner-uninstaller/id1013897218?mt=12)\n"},"frontmatter":{"date":"August 19, 2018","title":"Anaconda Uninstall on macOS","slug":"/2018-08-19/Anaconda-Uninstall-macOS","tags":["macOS","Anaconda","Python"]}},{"fields":{"path":"/blog/2018-08-15/AWS-발표-준비/"},"timeToRead":1,"internal":{"content":"\n(옮긴글…)\n\n7월 12일 AWS Serverless 모임 때 발표를 준비하는데 AWS에서 서비스하는 Lambda와 S3를 이용하여 PDF파일을 Image파일로 변환했던 방법을 소개하려고 합니다.\n\n[meetup](https://www.meetup.com/ko-KR/awskrug/events/252147208/?rv=ea1_v2&_xtd=gatlbWFpbF9jbGlja9oAJDdlMzVjMjM2LTY3YmQtNDZkMy05OGZmLTdmMmJiMjY4NDkzZA)에서 참여신청할수 있습니다.\n"},"frontmatter":{"date":"August 15, 2018","title":"발표 준비 중...","slug":"/2018-08-15/AWS-발표-준비","tags":["AWS","Serverless","AWS Lambda","S3"]}},{"fields":{"path":"/blog/2018-09-05/AUSG-2기-활동/"},"timeToRead":1,"internal":{"content":"\n조금 된 소식이지만 **AUSG(AWSKRUG University Student Group) 2기** 활동을 하게 되었습니다. 처음엔 지원을\n할까 말까도 굉장히 고민했습니다만 다행히도 대부분의 고민이 해결되었습니다. 아직 많은 사람들과 얘기 해보지는 못했지만 벌써 재밌고 다양한\n사람들을 만난 것 같구요. 재밌는 세션도 많이 볼수 있을거 같아서 기대됩니다 ㅎ\n\n# **활동목표**\n\n* AUSG 멤버들의 AWS학습을 위한 교육세션\n* 전파를 위한 세미나 주최\n* 외부 대학생 대상 교육\n* AWS, AWSKRUG의 공식 행사 서포트\n* Slack #university 모임 운영\n\n# 링크\n\n* [Slack AWSKRUG](http://awskrug.slack.com)\n* [Homepage(리뉴얼 예정)](http://www.awskr.org/)\n* [Facebook Group](https://www.facebook.com/groups/awskrug)"},"frontmatter":{"date":"September 05, 2018","title":"AUSG 2기로 활동하게 됐습니다.","slug":"/2018-09-05/AUSG-2기-활동","tags":["AWS","AWSKRUG","AUSG"]}},{"fields":{"path":"/blog/2018-09-02/Serverless-Docker-Beta-zeit/"},"timeToRead":9,"internal":{"content":"\n시간이 좀처럼 안나서 뜸뜸이 번역하고 있어서 나온지 꽤 됬는데도 아직 포스팅을 못했습니다😂 그래서 좀 부족하더라도 미리 올려 놓고 조금씩\n수정하려구요. 양해를 부탁드립니다.\n\n---\n\n얼마전에 메일로 Now를 만드는 회사인 Zeit에서 새소식이 왔습니다. 바로! [Serverless docker beta](https://zeit.co/blog/serverless-docker)!!!!(띠용🤔) 서버리스면 서버리스고 도커면 도커지 두개가 같이 있을 수 있나…??!!!!!! 도커가 서버리스로?! 아무튼 그래서 번역을 해보았습니다. 실제 사용 후기는 이후에 올려드리겠습니다. 오역이나 어설픈 부분은 알려주시기 바랍니다😄(도와줘서 고마워요 구글 번역기)\n\n---\n\n올해 [ZEIT Day Keynote](https://www.youtube.com/watch?v=yqACl3tRHNI)의 초점은 Now 클라우드 플랫폼의 새로운 가능성입니다. 특히, 우리는 Serverless Docker 개발에서 우리의 초점을 강조했습니다.\n\n오늘, 우리는 공개 베타 버전으로써 발표할 것입니다. 다음 기능을 제공합니다:\n\n- 1.5백만개의 배포 데이터를 기반으로한 콜드 부팅 성능가 10~20배 개선<br> - 대부분의 작업부하에서 1초 미만의 콜드 부팅(전체\n  왕복)으로 변환됩니다.<br> - A new `slot` configuration property which defines the\n  resource allocation in terms of CPU and Memory, defaulting to `c.125-m512` (.125\n  of a vCPU and 512MB of memory)\n- 이를 통해 응용 프로그램을 가장 적합한 제약 조건에 맞추고 특수 CPU 기능, GPU 코어 등에 길을 열어두었습니다.(paving the\n  road가 관용어인거 같은데 길을 열어두다, 가능성을 열다라는 뜻인거 같아요)\n- 엄격하게 지정된 가변 제한<br> - 최대 실행 시간 (기본값은 5 분, 최대 30 분)<br> - 마지막 요청 후 종료 시간 초과 (기본값은\n  1 분, 최대 5)<br> - 자동 스케일링 전에 최대 요청 동시성(기본값 10)\n- 배포에 대한 HTTP/2.0과 WebSocket의 연결을 지원<br> - 당신의 어플리케이션을 다시 function으로 작성할 필요가 없습니다.\n  다만, [계속 그것을 사용할 수 있습니다.](https://zeit.co/blog/serverless-docker#walkthrough)\n- Automatic port discovery. We no longer rely on the `EXPOSE` instruction. We\n  automatically forward traffic to the port of the process started by `CMD`\n\nRead on to learn how it works or head directly to our\n[examples](https://github.com/zeit/now-examples).\n\n# [실습 방법](https://zeit.co/blog/serverless-docker#walkthrough)\n\n## [Serverless Node.js Functions](https://zeit.co/blog/serverless-docker#serverless-node.js-functions)\n\n`micro`를 이용해 간단한 HTTP 서비스 함수를 배포 해봅시다:\n\n![](https://cdn-images-1.medium.com/max/1600/0*PBNCCGfFVAn1_Cec.gif)\n\n> `npm ci`로 빌드된 [node-function.now.sh](https://node-function.now.sh)을 통해 액세스 할 수\n> 있는 간단한 function입니다.\n\n여기서 일어나는 일들입니다:\n\n- 클라우드와는 다른 우리의 로컬 파일 시스템 배포가 만들어집니다.\n- A simple `Dockerfile` is used to hold the instructions to build the project\n- 간단한 `Dockerfile`은 프로젝트 빌드 지침을 보관하기 위해 사용됩니다.\n- Node.js version(`10`)과 package manager(`npm ci`)의 자체 설정으로 빌드합니다.\n- `index.js` 파일은 메인 함수가 들어가있습니다.\n- 이 serverless container는 125CPUs와 512MB 메모리로 제한됩니다.\n- DNS 조회+ TLS handshake + Cold Boot + 전체왕복까지 일어나는데 600ms~입니다.\n- Once the deployment instance is warm, subsequent requests take 100ms~\n- 일단 배포 인스턴스가 가동되었다면, 이후 요청은 100ms~입니다.\n\n이 작업을 수행하기 위한 요구사항은 오직 당신의 now.json에서 기능 플래그를 통해 베타를 활성화 하는 것입니다:\n\n## [Serverless Go + Websockets](https://zeit.co/blog/serverless-docker#serverless-go-+-websockets)\n\n이 기술의 능력을 조금 더 깊숙히 알아봅시다. 다음 예제는 Docker registry에서 Go로 작성된 이미지를 가져옵니다.\n\n![](https://cdn-images-1.medium.com/max/1600/0*xp5_bWGbCwEHsNj2.gif)\n\n> HTTP/2.0과 웹소켓을 사용하는 Serverless shell은\n> [terminal.now.sh](https://terminal.now.sh/)에서 사용가능합니다.\n\n이 데모의 주요사항:\n\n- 공개 Docker registry에서 변경되지 않은 `Dockerfile` 사용\n- 다른 프로그래밍 언어와 런타임: Go\n- 파일 시스템을 검사할 수 있는 우리의 능력으로 입증된 일시적인 상태 유지 - 5분(기본시간) 이후, 상태는 재활용됩니다.\n- 500ms 미만의 Cold 왕복. Go는 거대한 어플리케이션이지만 더 나은 시작 성능을 보여줍니다.(이 예제에서는 일반적으로 400~500ms)\n- 이 서비스는 초기화된 HTML를 제공하는 HTTP 요청에 응답합니다. 그리고 WebSocket 연결을 통해 PTY 데이터를 교환합니다.\n\n## [Serverless Rust(Global)](<https://zeit.co/blog/serverless-docker#serverless-rust-(global)>)\n\n이 인프라는 [Global Now](https://zeit.co/blog/multi-dc)와 합쳐져 매우 잘 작동합니다. 다시 말해, 모든\nGlobal locations에 serverless하게 배포하는데 하나의 플래그만 있으면 됩니다.\n\n여기 Rust + Hyper 배포 예제가 있습니다:\n\n![](https://cdn-images-1.medium.com/max/1600/0*wbO50Isx0jTJfIqV.gif)\n\n> [rust-http-microservice-v2.now.sh](https://rust-http-microservice-v2.now.sh), 모든\n> 지역에서 즉시 사용할 수 있는 Rust 마이크로서비스\n\n이것은 나머지 예제들과 비슷하지만, 우리는 `now --regions all`을 실행하는 것으로 처음부터 모든 지역에 바로 확장되었습니다.\n\n이것은 또한 다음을 실행하여 이미 배포된 후에도 확장할 수 있습니다:\n\n## [Automatic Horizontal Scalability(자동 수평 확장성)](https://zeit.co/blog/serverless-docker#automatic-horizontal-scalability)\n\n(정의하는 경계 안에서)당신이 정의한 파라매터로 자동 확장하는 이 시스템의 능력을 강조하기 위해서, 여기 `wrk`(load-testing\ntool)로 [stress test](https://ko.wikipedia.org/wiki/ì¤í¸ë ì¤_íì¤í¸)를 위한\n예제가 있습니다.\n\n![](https://cdn-images-1.medium.com/max/1600/0*mZOfNFEEqPGYaDRT.gif)\n\n> 즉각적이고 예측 가능한 수평적 확장성\n\n이 것은(우리 생각에) Serverless 배포의 가장 중요한 특징을 정의합니다. 하지만, 우리가 다음을 보게 되는 것만은 아닙니다.(>\n무슨말이죠..?)\n\n# [Serverless 컴퓨팅의 원리](https://zeit.co/blog/serverless-docker#principles-of-serverless-computing)\n\nWe selected these demos in particular to underline a very important point. We\nthink Serverless can be a very general computing model. One that does not\nrequire new protocols, new APIs and can support every programming language and\nframework without large rewrites.\n\nHere are three of the underlying ideas behind this new architecture.\n\n## [1. Focus on Code, Not Infrastructure](https://zeit.co/blog/serverless-docker#1.-focus-on-code,-not-infrastructure)\n\nServerless enables engineers to focus on code rather than managing servers, VMs,\nregistries, clusters, load balancers, availability zones, and so on.\n\nThis, in turn, allows you to define your engineering workflow solely around\nsource control and its associated tools (like pull requests). [Our recent GitHub\nintegration](https://zeit.co/github), therefore, makes it possible to deploy a\nDocker container in the cloud solely by creating a `Dockerfile`.\n\nIt is not sufficient to _ignore that the infrastructure is there_, or forget\nabout it. The execution model must make it so that manual intervention,\ninspection, replication, and monitoring or alert-based uptime assurance is\ncompletely unnecessary, which takes us to our next two points.\n\n[What Are the Benefits?](https://zeit.co/blog/serverless-docker#what-are-the-benefits)\n\nWhen we deployed the examples above, we didn’t have to deal with:\n\n- Clusters or federations of clusters\n- Build nodes or build farms\n- Container registries and authentication\n- Container image storage, garbage collection and distributed caching\n\n## [2. Deployments Should Self-Heal](https://zeit.co/blog/serverless-docker#2.-deployments-should-self-heal)\n\nA very common category of failure of software applications is associated with\nfailures that occur after programs get into states that the developers didn’t\nanticipate, usually arising after many _cycles_.\n\nIn other words, programs can fail unexpectedly from accumulating state over a\nlong lifespan of operation. Perhaps the most common example of this is a memory\nleak: the unanticipated growth of irreclaimable memory that ultimately concludes\nin a faulty application.\n\nServerless means never having to “try turning it off and back on again”\n\nServerless models completely remove this category of issues, ensuring that no\nrequest goes unserviced during the recycling, upgrading or scaling of an\napplication, even when it encounters runtime errors.\n\n[How Does Now Ensure This?](https://zeit.co/blog/serverless-docker#how-does-now-ensure-this)\n\nYour deployment instances are constantly recycling and rotating. Because of the\nrequest-driven nature of scheduling execution, combined with limits such as\nmaximum execution length, you avoid many common operational errors completely.\n\n## [3. Deployments Should Automatically and Predictably Scale](https://zeit.co/blog/serverless-docker#3.-deployments-should-automatically-and-predictably-scale)\n\nPerhaps the most important or appealing aspect of the serverless paradigm is the\npromise of _automatic scalability_.\n\nIn its most basic form, a function automatically scales with a 1:1 mapping of\nrequests to resource allocations. A request comes in, a new function is\nprovisioned or an existing one is re-used.\n\nWe have taken this a step further, by allowing you to customize the concurrency\nyour process can handle.\n\n# [Technical Details](https://zeit.co/blog/serverless-docker#technical-details)\n\nThis new infrastructure is already available to Docker deployments made in the\nfree tier, or for paying subscriptions that opt-into the feature via `now.json`:\n\nPlease ensure that your [Now CLI](https://zeit.co/download#now-cli) is up to\ndate, or deploy directly via our [GitHub integration](https://zeit.co/github) or\n[API](https://zeit.co/api).\n\n## [Limits](https://zeit.co/blog/serverless-docker#limits)\n\n[Hard Limits](https://zeit.co/blog/serverless-docker#hard-limits)\n\nThese limits are fixed. They are subject to change once the feature goes into\nGeneral Availability.\n\n- A maximum of `3` concurrent deployment instances for OSS\n- A maximum of `10` concurrent deployment instances per subscription\n- A maximum of `500` concurrent requests/connections across deployments per\n  subscription\n\n[Soft Limits](https://zeit.co/blog/serverless-docker#soft-limits)\n\nThese limits are configurable in `now.json` as part of a `limits` object.\n\n- `maxConcurrentReqs` max concurrency of each process (min `1`, max `256`, default\n  `10`)\n- `duration` max amount of time in ms your process can run (min/default 5 minutes,\n  max 30 minutes)\n- `timeout` how long in _ms_ to wait after the last request to downscale\n  (min/default 1 minute, max 30 minutes)\n\n## [Pricing](https://zeit.co/blog/serverless-docker#pricing)\n\nWhile in beta, we require a paid subscription to be able to go over the maximum\nof `3` concurrent deployment instances. Current rates apply and are subject to\nchange.\n\n# [Next up: Faster, More Capable, Smaller](https://zeit.co/blog/serverless-docker#next-up:-faster,-more-capable,-smaller)\n\n## [Faster Cold Start](https://zeit.co/blog/serverless-docker#faster-cold-start)\n\nDespite having so dramatically sped up instantiation times, we still have very\nsignificant room for improvement.\n\nWe are excited about unveiling some of these over the coming weeks before the\nnew infrastructure goes into General Availability.\n\n## [Additional](https://zeit.co/blog/serverless-docker#additionalslotconfigurations) `slot` [Configurations](https://zeit.co/blog/serverless-docker#additionalslotconfigurations)\n\nWe will introduce new `slot` identifiers so that you can fit your applications\ninto other CPU/memory combinations.\n\nThis is important for resource-intensive applications.\n\n## [Smaller Images](https://zeit.co/blog/serverless-docker#smaller-images)\n\nWhen your code is built, we post-process the resulting snapshot and let you know\nwhat the total size is.\n\nWe are confident that in its present form, our system can fit the vast majority\nof our customers’ workloads without any issues.\n\nHowever, we are currently developing improvements to optimize this dimension\nfurther, without you having to make any changes.\n\n# [결론](https://zeit.co/blog/serverless-docker#conclusions)\n\n이 베타 버전은 지난 2년동안 수백만 건의 배포를 완료한 대규모 배포와 다양한 사용자 기반의 교훈과 경험이 포함되어 있습니다.\n\n시작하기 위해서, 이 릴리즈에서 함께 제공한 종합 예제 목록을 참고하시는 것을 제안합니다.\n\n이후 몇 주 동안, 우리는 새로운 제품에 대한 더 자세한 기사와 문서를 공유 할 것입니다.\n\n이 기간 동안 당신의 의견은 중요합니다. 제발 저희에게 얼마나 잘 작동하는지 [알려주세요.](https://zeit.co/chat)\n"},"frontmatter":{"date":"September 02, 2018","title":"(번역 중)Serverless Docker Beta","slug":"/2018-09-02/Serverless-Docker-Beta-zeit","tags":["Docker","Serverless","Now","Zeit"]}},{"fields":{"path":"/blog/2018-09-05/AWS-Lambda-병렬-처리-PDF-Image-변환/"},"timeToRead":4,"internal":{"content":"\n> **이 글은 7월에 있었던 AWSKRUG Serverless 발표때 사용한 내용입니다.**\n\n> **주의! 이 글은 삽질의 경험이 녹아든 글입니다. 필요하신 정보가 다 담겨있지 않을 수 있습니다.**\n\n회사에서 PDF로 나온 교재를 이미지로 변환해야하는 일이 있었는데요. 시중에 있는 툴은 모두 한 페이지씩 변환하기 때문에 오래걸리더라구요. 한\n페이지에 대략 10~15초 정도가 걸렸기 때문에 100 페이지 이상 이루어지는 교재의 경우 권당 15분 이상씩 걸리는 경우가 허다했습니다.\n\n`(10+@)초 + N페이지 = 파일당 변환 시간`\n\n`파일당 변환시간 + 변환 요청 파일 수`\n\n특히 나중에 도입될 변환 서비스에서 너무 과한 시간이 걸릴 것으로 판단해서 병렬처리를 도입하려고 하였습니다. 그런데 PC에서 병렬처리는 한계가\n있기 때문에 AWS Lambda를 이용하기로 결정하였습니다.\n\n# 1. 고민들\n\n작업을 시작하기 전에 했던 고민들이 있었는데요. 첫번째는 어떤 Program Language를 사용할까 하는 것이었습니다. Lambda에서\n실행할 것이었기 때문에 Lambda에서 운영되는 언어중에 골랐어야 했습니다.\n\n후보로 있었던 언어는\n\n1.  파이썬\n2.  Javascript\n3.  Java\n4.  C#\n\n제가 파이썬을 자주 사용하고 오랫동안 좋아하는 언어였기 때문에 처음엔 파이썬을 사용하려고 했습니다. 그런데 회사에서 작업을 Node.js로\n구성하고 있고 요즘 작업 대부분을 Node.js 환경에서 하다보니 Node.js로 시작하는게 좋겠다 싶어서 Javascript로 처음엔\n시작했습니다.\n\n# 2. 삽을 들다\n\nJavascript에서 PDF 렌더링을 Mozilla에서 만든 [pdf.js](https://github.com/mozilla/pdf.js)를\n이용했습니다. 이 pdf.js는 canvas에 의존적인데요. node에서는 canvas가 없기 때문에\n[canvas-node](https://github.com/Automattic/node-canvas) 를 설치해야합니다. Lambda에서\n설치하기 위한 방법은 [이 가이드](https://github.com/Automattic/node-canvas/wiki/Installation:-AWS-Lambda)에 잘\n나와있습니다. canvas-node의 경우 Binary file로 되어있습니다. Lambda에 사용자 환경을 구성하기 위해서는 EC2에서\nAMI(Amazon Machine Image) 환경을 구성하고 Lambda로 배포해야합니다. 그래서 가이드에 나온대로 진행하고 예제 소스를\n사용했습니다. Lambda에서 작동해야하기 때문에 Local환경에서는 테스트하지 않고 바로 Lambda에 소스를 올렸습니다.\n\n```javascript\n/**\n  * 이 예제는 가이드에 나와있는 것과 동일한 예제입니다.\n  * 저는 이 소스를 serverless framework 환경에 맞춰서 수정하였습니다.\n  */\nlet {createCanvas} = require(\"canvas\");\n​\nfunction hello(event, context, callback) {\n  let\n    canvas = createCanvas(200, 200),\n    ctx = canvas.getContext('2d');\n  ​\n  // Write \"Awesome!\"\n  ctx.font = '30px Impact';\n  ctx.rotate(0.1);\n  ctx.fillText('Awesome!', 50, 100);\n  ​\n  // Draw line under text\n  let\n    text = ctx.measureText('Awesome!');\n  ctx.strokeStyle = 'rgba(0,0,0,0.5)';\n  ctx.beginPath();\n  ctx.lineTo(50, 102);\n  ctx.lineTo(50 + text.width, 102);\n  ctx.stroke();\n  ​\n  callback(null, '<img src=\"' + canvas.toDataURL() + '\" />');\n}\n​\nmodule.exports = {hello};\n```\n\n예제는 잘 실행되었습니다. 변환속도도 괜찮고 맘에 들었습니다. 이거면 되겠다 싶어서 소스를 수정하기 시작했습니다. 예제를 조금 수정해서 한글\n텍스트를 써서 작성하고 실행했습니다. 그런데 그때 예상치 못한 문제를 만났습니다.\n\n# 3. 예상치 못한 문제를 만나다\n\n테스트용 소스는 **충격적**이게도 한글 텍스트를 제대로 인식하지 못하고 글자가 깨져서 안나왔습니다. 문제를 해결해보려고 여러 방법을\n시도해봤는데요.\n\n1.  인코딩 문제\n2.  한글 폰트 문제\n3.  시스템 언어 문제\n\n먼저, 인코딩 문제의 경우 EUC-KR(윈도우에서의 한글 인코딩), UTF-8 등 한글 지원 인코딩을 적용해봐도 해결되지 않았습니다. 그래서\n두번째로 한글 폰트 문제를 해결해보려고 오랜시간 삽질 끝에 한글 폰트를 넣고 실행해봤습니다만 문제는 마찬가지였습니다. 제가 모르는 방법으로 해결\n방법이 있었겠지만 저는 그 방법을 찾지 못했습니다. 결국 오랜시간의 삽질에도 불구하고 그래서 과감하게 미련없이 다른 언어의 다른 방법으로\n환승했습니다.\n\n# 4. 도와줘요 Adobe!\n\n결국, 다른 남은 언어 중에서 Python, Java의 선택지를 생각하면서 알아보다가 Python에서 PDF Rendering Library 중\n유명한 것이 Poppler입니다. 그런데 이 라이브러리도 Bynary file에 의존적이었습니다. 반면에 Java에서 사용하는 라이브러리인\nPDFbox는 Adobe에서 Adobe Reader를 만들때 사용한 동일한 라이브러입니다. 이 라이브러리는 OS에 최적화된 파일에 의존하지 않고\nJava의 JVM 바이트 코드에서 작동하는 라이브러리만으로 구성되어 있었기 때문에 PC에서 컴파일하여 배포하면 끝나는 형태였습니다. 이미\nAMI를 통해 배포하는 것에 굉~장한 귀찮음을 느끼고 있었기 때문에 저는 바로 Java로 작업을 시작하였습니다.\n\n> _Adobe에서 오픈소스로 제공하는 이 PDFbox라는 라이브러리는 Adobe Reader 프로그램에서 사용하는만큼 Adobe Reader에서\n> 정상적으로 작동하면 이 라이브러리를 사용했을 때도 작동해야 한다고 하는 문구가 매우 설득력 있었습니다._\n\n그래서 새로운 삽을 들었습니다. Repository를 만들고 Serverless framework에서 Gradle 기반 Java\nTemplate로 프로젝트를 만들었습니다. Gradle을 통해서 PDFbox를 받고 Main Class에서 PDFbox를 load 하고\nLambda 이벤트를 받으면 이벤트에 있는 S3 주소를 받아서 그 위치에 변환된 Image 파일을 저장하도록 만들고 첫 페이지를 변환했습니다.\n중간에 여러번의 삽질이 있었지만 결국 성공했습니다. 영문 페이지도 한글 페이지도 성공적으로 변환되었습니다. 이미지 등도 잘 변환되었구요. 이때\n엄청 환호성을 질렀습니다. 글로는 간략하게 설명됬었지만 2~3일 정도 고생했거든요.\n\n# 5. 병렬처리 시작\n\n꽤 오랜시간 고생했지만 아직 본래 하려던 내용은 시작도 못했습니다. 애초에 목적은 변환이 아니라 병렬처리였으니까요. 그래서 소스를 병렬로\n처리하기 위해서 작업을 시작했습니다. 병렬로 변환하게 만드는 소스를 짜기까지는 오래 걸리지 않았습니다. 애초에 잘 작동하는 소스로 Lambda를\n비동기로 병렬 Invoke하고 취합해서 저장하고 결과를 돌려주면 되었으니까요.\n\nLambda의 함수 내에서 분기를 만들어줬습니다. 큰 의미없이 함수를 여러개 만드는건 관리도 불편하더라구요. 함수를 만들때 S3 Event가\n발생할 것도 고려하여 작성했습니다. 특정 경로는 자동 변환되고 User마다 올리는 변환에는 수동으로 실행하도록 하였습니다.(다 되었는지 확인하는\nResponse가 있기 때문에)\n\nLambda FlowGraph\n\n![](https://cdn-images-1.medium.com/max/1600/0*SpmAyLY7WapZpuFF.png)\n\nrecievePage3EvnetTrigger FlowChart\n\n![](https://cdn-images-1.medium.com/max/1600/0*wyNsMpINP29vTzW2.png)\n\n![](https://cdn-images-1.medium.com/max/1600/0*zRbsJorov7cF5VPB.png)\n\n# 6. 결과와 문제점\n\n자, 이제 프로그램은 완성되었습니다. 길고 긴 시간이 걸렸습니다만 소스는 무사히 완성되었네요. 실행방법은 두가지입니다.\n\n1.  S3에 이벤트가 발생할수 있는 경로에 PDF파일을 업로드\n1.  S3에 PDF파일을 업로드하고 Lambda를 Invoke\n\n변환되어 저장된 페이지의 이미지 파일 이름을 알아야하기 때문에 저는 페이지별로 경로를 모은 index 정보가 담긴 json파일도 저장했습니다.\n애초에 파일당 수십분씩 걸리던 PDF 변환이 30초 안에 끝나는 마법을 보면서 혼자 피식피식 했습니다. 하지만 사용하면서 몇가지 문제점도\n있었는데요.\n\n1.  람다 동시성 예약 1000건\n1.  특수한 글자 인식 오류\n\n# 시도해보면 좋았을 것들\n\n- Python\n- AWS SQS(Simple Queue Service)\n- 엄격한 권한 관리\n\n# 7. Demo\n\n이 [Repository](https://github.com/witherion/PdfToImageOnLambda)에서 해당 소스를 가져올수\n있습니다. 맘에 드신다면 별⭐️도 췍췍!\n"},"frontmatter":{"date":"September 05, 2018","title":"AWS Lambda 병렬 처리를 통한 PDF to Image 변환 삽질기","slug":"/2018-09-05/AWS-Lambda-병렬-처리-PDF-Image-변환","tags":["Serverless","AWS Lambda","Pdf","Image","Parallel Computing"]}},{"fields":{"path":"/blog/2018-09-11/Nuxt2-nuxt-edge-Typescript/"},"timeToRead":3,"internal":{"content":"\nNuxt 2.0에서 Typescript를 적용하는 방법에 대해서 한번에 요약되어 있는 글이 없어서 글로 정리하고 [보일러플레이트로 repo를 만들어 뒀습니다.](https://github.com/yoonhoGo/Nuxt-edge-with-Typescript-boilerplate)\n\n*****\n\n우선 vue-cli를 이용하여 nuxt starter-template을 받아줍니다.\n\n1.  `yarn global add @vue/cli @vue/cli-init`\n1.  `vue init nuxt-community/starter-template <project-name>`\n\n그리고 기존에 있던 nuxt를 지우고 nuxt-edge(Nuxt.js 2.0)을 받아줍니다.\n\n`yarn remove nuxt && yarn add next-edge`\n\n이것 자체로 nuxt-edge 설정은 완료되었습니다. 이제 Typescript를 설정을 해줍니다. Typescript와 nuxt에서 내부적으로\n돌아가는 webpack을 위한 ts-loader 그리고 lint 적용을 위해서 tslint를 devDependencies에 설치해줍니다.\n\n`yarn add typescript ts-loader tslint --dev`\n\n설치가 완료되면 초기 설정 파일을 만들어줍니다. 아래 명령어를 실행하면 tsconfig.json과 tslint.json 파일이 각각 생성됩니다.\ntslint는 [홈페이지](https://palantir.github.io/tslint/)를 참고해서 rule을 수정하시면 됩니다. \\**Gist 내용은 Copy&Paste 해주시면 됩니다.*\n\n`tsc --init && tslint --init`\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    /* Basic Options */\n    \"target\": \"es5\",                          /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */\n    \"module\": \"commonjs\",                     /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */\n    \"allowJs\": true,                       /* Allow javascript files to be compiled. */\n    \"outDir\": \"./.dist\",                        /* Redirect output structure to the directory. */\n    /* Strict Type-Checking Options */\n    \"strict\": true,                           /* Enable all strict type-checking options. */\n    /* Module Resolution Options */\n    \"moduleResolution\": \"node\",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */\n    \"baseUrl\": \"./src\",                       /* Base directory to resolve non-absolute module names. */\n    \"paths\": {\n      \"*\": [\"node_modules/*\"],\n      \"~/*\": [\"src/*\"],\n      \"@/*\": [\"types/*\"]\n    },                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */\n    \"esModuleInterop\": true,                   /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */\n    /* Experimental Options */\n    \"experimentalDecorators\": true,        /* Enables experimental support for ES7 decorators. */\n  }\n}\n```\n\n설정이 완료 되셨으면 Nuxt에서 typescript를 build 할 때 제대로 load 할 수 있도록 ts-loader를 연결해줍니다. \\**Gist 내용은 Copy&Paste 해주시면 됩니다.*\n\n```javascript\n// nuxt.config.js\nmodule.exports = {\n  srcDir: 'src/',\n  extensions: ['js', 'ts'],\n  /*\n  ** Headers of the page\n  */\n  head: {\n    title: 'portfolio',\n    meta: [\n      { charset: 'utf-8' },\n      { name: 'viewport', content: 'width=device-width, initial-scale=1' },\n      { hid: 'description', name: 'description', content: 'my portfolio site' }\n    ],\n    link: [\n      { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' }\n    ]\n  },\n  /*\n  ** Customize the progress bar color\n  */\n  loading: { color: '#3B8070' },\n  /*\n  ** Build configuration\n  */\n  build: {\n    /*\n    ** Run ESLint on save\n    */\n    extend(config, { isServer }) {\n      const tsLoader = {\n        loader: 'ts-loader',\n        options: { appendTsSuffixTo: [/\\.vue$/], transpileOnly: true },\n        exclude: [/vendor/, /\\.nuxt/],\n      };\n      config.module.rules.push({ test: /((client|server)\\.js)|(\\.tsx?)$/, ...tsLoader });\n      config.resolve.extensions.push('.ts');\n      config.module.rules.map((rule) => {\n        if (rule.loader === 'vue-loader') { rule.options.loaders = { ts: tsLoader }; }\n        return rule;\n      });\n\n      if (isServer) { config.externals = []; }\n    }\n  }\n}\n```\n\n마지막으로 vue에서 typescript를 쓸 때 다른 Component를 import할 수 있도록 .vue 파일 타입을 정의해줍니다. \\**Gist 내용은 Copy&Paste 해주시면 됩니다.*\n\n```typescript\n// types/index.d.ts\ndeclare module '*.vue' {\n  import Vue, { VueConstructor } from 'vue'\n  const vue: VueConstructor<Vue>\n  export default vue\n}\n```\n\n*****\n\n#### 선택가능한 부분\n\n만약 class형태로 components를 나누신다면\n[nuxt-class-component](https://github.com/nuxt-community/nuxt-class-component)와\n[nuxt-property-decorator](https://github.com/nuxt-community/nuxt-property-decorator)를\n참고하시기 바랍니다. 보일러플레이트에서는 적용 되었습니다. `yarn add nuxt-property-decorator`\n\n*****\n\n#### 결론\n\n이제 `yarn dev`를 실행하여 테스트 해보시기 바랍니다.\n"},"frontmatter":{"date":"September 11, 2018","title":"Nuxt 2.0(nuxt-edge) + Typescript","slug":"/2018-09-11/Nuxt2-nuxt-edge-Typescript","tags":["Nuxt.js","Vue.js","Typescript"]}},{"fields":{"path":"/blog/2018-09-14/AUSG-seminar-발표-준비/"},"timeToRead":1,"internal":{"content":"\n![AUSG 초보자를 위한 AWS 뿌시기 포스터](https://miro.medium.com/max/1080/0*iRNQHWdaxqNz2m1v)\n\n[**Create a Meetup Account** *지역 커뮤니티에서 마음에 드는 Meetup을 찾아 나와 같은 관심사를 가진 사람들을 만나보세요.*www.meetup.com](https://www.meetup.com/ko-KR/awskrug/events/254611413/?_xtd=gqFyqTIzMzExMzEwOaFwo3dlYg&from=ref)\n\n> 자세한 내용은 링크를 확인해주세요!\n\n---\n\n[AUSG Seminar Series]\n2018 F/W 초보자를 위한 AWS 뿌시기\n\n지난 겨울에 성황리에 진행되었던 AUSG의 “초보자를 위한 AWS 뿌시기” 가 돌아왔습니다.\n\n2018 F/W 시즌을 맞이하여 더욱 다양하고 흥미있는 주제들로 준비하였습니다.\n\n1회차\n\n- AUSG 고윤호님\n- Node.js 서버리스 프레임웍을 사용하여 싱글페이지 포트폴리오 제작하기\n\n2회차 ~\n\n- 10월 개봉\n\n# <세부 내용>\n\n1. 주최 : AUSG (AWSKRUG 대학생 그룹)\n\n2. 내용 : Node.js 서버리스 프레임웍을 사용하여 싱글페이지 포트폴리오 제작하기\n\n3. 대상 : AWS를 활용한 개발을 배워보고 싶은 누구나\n\n4. 장소 : 서울특별시 강남구 논현로85길 46 GALA빌딩 메가존(주) B1\n\n5. 시간 : 9/19(수) 19:00 ~ 21:30\n\n6. 회비 : 10,000원\n\n<기타 문의>\nSlack의 #ausg 채널 또는 ausg.awskrug@gmail.com을 통해 문의주세요.\nSlack의 AWSKRUG workspace에 가입 방법은 다음 링크를 참조해주시기 바랍니다.\n[http://www.awskr.org/slack/](http://www.awskr.org/slack/)\n"},"frontmatter":{"date":"September 14, 2018","title":"AUSG 세미나 발표 준비 중입니다","slug":"/2018-09-14/AUSG-seminar-발표-준비","tags":[]}}]